<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR é­”æ³•ä»™å¥³æ£’ (æœ€ç»ˆä¿®å¤ç‰ˆ)</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
    if (typeof process === 'object' && typeof require === 'function') {
        window._oldModule = window.module;
        window.module = undefined; window.exports = undefined; window.__dirname = ''; 
    }
    </script>

    <style>
        /* --- æ ¸å¿ƒæ ·å¼ --- */
        :root {
            --glass-bg: rgba(20, 20, 28, 0.75);
            --glass-border: rgba(255, 255, 255, 0.12);
            --accent-color: #ffd700;
            --accent-glow: rgba(255, 215, 0, 0.4);
            --text-main: #ffffff;
        }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: -apple-system, sans-serif; color: var(--text-main); user-select: none; -webkit-user-select: none; }
        canvas { position: absolute; top: 0; left: 0; }
        
        /* éšè—è§†é¢‘ä½†ä¿ç•™å ä½ */
        #input_video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        /* --- å¯åŠ¨é®ç½©å±‚ (è§£å†³ Safari è‡ªåŠ¨æ’­æ”¾çš„å…³é”®) --- */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        #start-btn {
            padding: 16px 40px; font-size: 1.2rem; background: var(--accent-color); color: #000;
            border: none; border-radius: 50px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 25px var(--accent-glow); animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }
        #loading-text { margin-top: 20px; color: #aaa; font-size: 0.9rem; }

        /* --- æ¸¸æˆ UI --- */
        .top-bar { position: absolute; top: 20px; left: 24px; right: 24px; display: flex; justify-content: space-between; z-index: 60; pointer-events: none; }
        .btn-icon { background: var(--glass-bg); border: 1px solid var(--glass-border); color: white; padding: 10px 16px; border-radius: 12px; cursor: pointer; backdrop-filter: blur(12px); pointer-events: auto; display: flex; gap: 8px; align-items: center;}
        
        #settings-panel { position: absolute; top: 70px; left: 24px; z-index: 60; background: rgba(18, 18, 24, 0.9); border: 1px solid var(--glass-border); padding: 20px; border-radius: 16px; width: 200px; display: none; flex-direction: column; gap: 15px; pointer-events: auto; }
        .toggle-switch { width: 40px; height: 20px; appearance: none; background: rgba(255,255,255,0.2); border-radius: 20px; position: relative; outline: none; transition: 0.3s; }
        .toggle-switch:checked { background: var(--accent-color); }
        .toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%; transition: 0.3s; }
        .toggle-switch:checked::after { transform: translateX(20px); }

        #status-container { position: absolute; top: 20px; left: 0; right: 0; display: flex; justify-content: center; pointer-events: none; z-index: 50; }
        #status-bar { display: flex; gap: 12px; background: var(--glass-bg); padding: 6px 12px; border-radius: 24px; border: 1px solid var(--glass-border); }
        .badge { padding: 4px 10px; border-radius: 12px; font-size: 0.8rem; opacity: 0.3; transition: 0.3s; color: white; }
        .badge.active { opacity: 1; background: var(--accent-glow); color: #fff; transform: scale(1.1); font-weight: bold; }
        
        #tips { position: absolute; bottom: 30px; width: 100%; text-align: center; z-index: 10; font-size: 0.9rem; color: rgba(255,255,255,0.7); pointer-events: none; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <button id="start-btn" onclick="startApp()">âœ¨ ç‚¹å‡»å¼€å¯é­”æ³• âœ¨</button>
        <div id="loading-text">å‡†å¤‡å°±ç»ª</div>
    </div>

    <div class="top-bar">
        <div class="btn-icon" onclick="toggleSettings()"><span>âš™ï¸ è®¾ç½®</span></div>
        <div class="btn-icon" style="border-color: rgba(255,100,100,0.3)" onclick="exitToRPG()"><span>ğŸšª é€€å‡º</span></div>
    </div>

    <div id="settings-panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <span>åŒæŒæ¨¡å¼</span>
            <input type="checkbox" id="dual-mode-toggle" class="toggle-switch" onchange="updateSettings()">
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <span>èƒŒæ™¯å…‰ç‚¹</span>
            <select id="bg-style-select" onchange="updateSettings()" style="background:#333; color:white; border:none; padding:5px;">
                <option value="classic">ç»å…¸</option>
                <option value="star">æ˜Ÿå…‰</option>
                <option value="none">å…³é—­</option>
            </select>
        </div>
    </div>

    <div id="status-container">
        <div id="status-bar">
            <div class="badge" id="badge-pinch">ğŸ”¥ ç‚¹ç«</div>
            <div class="badge" id="badge-peace">ğŸš€ æé€Ÿ</div>
            <div class="badge" id="badge-palm">ğŸ¨ æ¢è‰²</div>
        </div>
    </div>

    <div id="tips">æåˆ:ç‚¹ç‡ƒ Â· æ¯”è€¶:å–·å°„ Â· å¼ æ‰‹:æ¢è‰²</div>

    <video id="input_video" playsinline webkit-playsinline muted></video>
    <canvas id="bgCanvas"></canvas>
    <canvas id="fgCanvas"></canvas>

<script>
    // --- æ ¸å¿ƒå˜é‡ ---
    const videoElement = document.getElementById('input_video');
    const bgCanvas = document.getElementById('bgCanvas');
    const fgCanvas = document.getElementById('fgCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const fgCtx = fgCanvas.getContext('2d');
    const loadingText = document.getElementById('loading-text');
    let width, height;
    let hands;

    // --- çª—å£å°ºå¯¸ç®¡ç† ---
    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        bgCanvas.width = fgCanvas.width = width;
        bgCanvas.height = fgCanvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- å¯åŠ¨æµç¨‹ (é›†æˆä¹‹å‰çš„æˆåŠŸç»éªŒ) ---
    async function startApp() {
        const btn = document.getElementById('start-btn');
        btn.style.display = 'none';
        loadingText.innerHTML = "æ­£åœ¨å¬å”¤ AI æ¨¡å‹ (é¦–æ¬¡åŠ è½½çº¦10ç§’)...";

        try {
            // 1. åˆå§‹åŒ– MediaPipe (èµ° CDN)
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults); // ç»‘å®šåˆ°æ¸¸æˆé€»è¾‘

            // 2. å¯åŠ¨æ‘„åƒå¤´
            loadingText.innerHTML = "æ­£åœ¨è¿æ¥æ‘„åƒå¤´...";
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "user" },
                audio: false
            });

            videoElement.srcObject = stream;
            
            // 3. ç¡®ä¿è§†é¢‘æ’­æ”¾ (Safari å…³é”®)
            await new Promise((resolve) => videoElement.onloadedmetadata = resolve);
            await videoElement.play();

            // 4. å¼€å§‹å¾ªç¯
            loadingText.innerHTML = "é­”æ³•åŠ è½½ä¸­...";
            processVideoLoop();

        } catch (e) {
            loadingText.innerHTML = `<span style="color:red">å¯åŠ¨å¤±è´¥: ${e.message}</span>`;
            btn.style.display = 'block';
            btn.innerText = "é‡è¯•";
        }
    }

    // --- è§†é¢‘å¸§å¤„ç†å¾ªç¯ ---
    async function processVideoLoop() {
        if (!videoElement.paused && !videoElement.ended && videoElement.readyState >= 2) {
            await hands.send({image: videoElement});
        }
        requestAnimationFrame(processVideoLoop);
    }

    // --- æ¸¸æˆé€»è¾‘é›†æˆ (å·²æ¢å¤æ‰€æœ‰ç‰¹æ•ˆ) ---
    
    // 1. ç‰©ç†ç¨³å®šå™¨
    class Stabilizer {
        constructor(minCutoff = 0.1, beta = 2.0) {
            this.x = 0; this.y = 0; this.dx = 0; this.dy = 0;
            this.lastX = 0; this.lastY = 0; this.lastTime = performance.now();
            this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = 1.0; 
        }
        update(targetX, targetY) {
            const now = performance.now();
            const dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            if (dt <= 0) return { x: this.x, y: this.y };
            let dx = (targetX - this.lastX) / dt;
            let dy = (targetY - this.lastY) / dt;
            let dAlpha = this.alpha(this.dCutoff, dt);
            this.dx = this.lerp(this.dx, dx, dAlpha);
            this.dy = this.lerp(this.dy, dy, dAlpha);
            let cutoff = this.minCutoff + this.beta * Math.abs(Math.sqrt(this.dx*this.dx + this.dy*this.dy));
            let alpha = this.alpha(cutoff, dt);
            this.x = this.lerp(this.x, targetX, alpha);
            this.y = this.lerp(this.y, targetY, alpha);
            this.lastX = targetX; this.lastY = targetY;
            return { x: this.x, y: this.y };
        }
        alpha(cutoff, dt) { let tau = 1.0 / (2 * Math.PI * cutoff); return 1.0 / (1.0 + tau / dt); }
        lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
    }
    class ValueStabilizer {
        constructor(smoothing = 0.1) { this.val = 0; this.smoothing = smoothing; }
        update(target) { this.val += (target - this.val) * this.smoothing; return this.val; }
    }

    // 2. é¢œè‰²å®šä¹‰
    const colors = [
        { hue: 45, sat: 100, light: 75 },
        { hue: 190, sat: 100, light: 70 },   
        { hue: 320, sat: 100, light: 70 },   
        { hue: 140, sat: 100, light: 75 },   
        { hue: 0, sat: 0, light: 100 }       
    ];
    let currentColorIdx = 0;

    // 3. ç²’å­ç³»ç»Ÿ
    const appSettings = { bgStyle: 'classic', dualMode: false };
    
    class Particle {
        constructor(x, y, type, handVel = {x:0, y:0}, isTurbo = false) {
            this.x = x; this.y = y; this.type = type;
            const angle = Math.random() * Math.PI * 2;
            
            if (type === 'bg') {
                const speed = Math.random() * 4 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.05; this.friction = 0.96;
                this.life = 1.0; this.decay = Math.random() * 0.015 + 0.01;
                this.hue = Math.random() * 360;
                this.size = Math.random() * 2 + 1;
                this.style = appSettings.bgStyle; 
                this.rot = Math.random() * 360;
            } else {
                const baseSpeed = isTurbo ? (Math.random() * 10 + 3) : (Math.random() * 5 + 1);
                this.vx = Math.cos(angle) * baseSpeed + (handVel.x * 0.3);
                this.vy = Math.sin(angle) * baseSpeed + (handVel.y * 0.3);
                this.gravity = 0.2; this.friction = 0.94;
                this.life = 1.0; this.decay = Math.random() * 0.03 + 0.01;
                const theme = colors[currentColorIdx];
                this.hue = theme.hue + (Math.random() * 30 - 15);
                this.sat = theme.sat;
                this.light = theme.light + Math.random() * 20;
                this.size = (Math.random() * 2.5 + 1) * (isTurbo ? 1.8 : 1.0);
            }
        }
        update() {
            this.vx *= this.friction; this.vy *= this.friction;
            this.vy += this.gravity; this.x += this.vx; this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.life;
            if (this.type === 'bg') {
                ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.life})`;
                if (this.style === 'star') {
                    ctx.translate(this.x, this.y); ctx.rotate(this.rot * Math.PI / 180); this.rot += 2;
                    // ç®€å•çš„æ˜Ÿæ˜Ÿç»˜åˆ¶
                    ctx.beginPath();
                    for(let i=0;i<5;i++){
                       ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*this.size*2, -Math.sin((18+i*72)/180*Math.PI)*this.size*2);
                       ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*this.size, -Math.sin((54+i*72)/180*Math.PI)*this.size);
                    }
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                }
            } else {
                ctx.fillStyle = `hsl(${this.hue}, ${this.sat}%, ${this.light}%)`;
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = this.size > 2 ? 15 : 5;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }
    }

    let bgParticles = [];
    let fgParticles = [];
    let bgIntervalId = null;

    function resetBgGenerator() {
        if (bgIntervalId) clearInterval(bgIntervalId);
        if (appSettings.bgStyle === 'none') return;
        bgIntervalId = setInterval(() => {
            const x = Math.random() * width;
            const y = height * 0.2 + Math.random() * (height * 0.4);
            const particleCount = 30;
            for(let i=0; i<particleCount; i++) bgParticles.push(new Particle(x, y, 'bg'));
        }, 3000);
    }
    resetBgGenerator();

    // 4. æ‰‹éƒ¨å®ä¾‹ç±»
    class HandInstance {
        constructor() {
            this.pos = { x: -100, y: -100 };
            this.lastPos = { x: -100, y: -100 };
            this.velocity = { x: 0, y: 0 };
            this.stabilizer = new Stabilizer(0.05, 0.8);
            this.angleStabilizer = new ValueStabilizer(0.12);
            this.stickAngle = 0;
            this.gesture = { isDetected: false, isPinching: false, isTurbo: false, isPalmOpen: false };
            this.lastSeen = 0;
        }
        update(landmarks, now) {
            this.lastSeen = now;
            this.gesture.isDetected = true;
            const p9 = landmarks[9], p0 = landmarks[0];
            const rawX = (1 - (p9.x * 0.75 + p0.x * 0.25)) * width;
            const rawY = (p9.y * 0.75 + p0.y * 0.25) * height;
            const smoothed = this.stabilizer.update(rawX, rawY);
            this.pos.x = smoothed.x; this.pos.y = smoothed.y;
            this.velocity.x = this.pos.x - this.lastPos.x; this.velocity.y = this.pos.y - this.lastPos.y;
            this.lastPos.x = this.pos.x; this.lastPos.y = this.pos.y;
            let targetTilt = Math.max(-35, Math.min(35, -this.velocity.x * 2.0));
            this.stickAngle = this.angleStabilizer.update(targetTilt);
            this.detectGestures(landmarks);
        }
        detectGestures(landmarks) {
            const indexTip = landmarks[8], thumbTip = landmarks[4];
            const tipsY = [landmarks[8].y, landmarks[12].y, landmarks[16].y, landmarks[20].y];
            const pipsY = [landmarks[6].y, landmarks[10].y, landmarks[14].y, landmarks[18].y];
            const pinchDist = Math.hypot((indexTip.x - thumbTip.x), (indexTip.y - thumbTip.y));
            this.gesture.isPinching = pinchDist < 0.08; 
            const isOpen = [tipsY[0]<pipsY[0], tipsY[1]<pipsY[1], tipsY[2]<pipsY[2], tipsY[3]<pipsY[3]];
            this.gesture.isTurbo = isOpen[0] && isOpen[1] && !isOpen[2] && !isOpen[3];
            this.gesture.isPalmOpen = isOpen[0] && isOpen[1] && isOpen[2] && isOpen[3];
        }
    }

    const handInstances = new Map();
    handInstances.set('Left', new HandInstance());
    handInstances.set('Right', new HandInstance());
    
    let globalGestureState = { lastColorChangeTime: 0 };
    const badges = {
        pinch: document.getElementById('badge-pinch'),
        peace: document.getElementById('badge-peace'),
        palm: document.getElementById('badge-palm')
    };

    // 5. æ›´æ–°çŠ¶æ€ä¸UI
    let isFirstSuccess = true;
    function onResults(results) {
        // æˆåŠŸè·å–ç»“æœï¼Œéšè—é®ç½©å±‚
        if (isFirstSuccess) {
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
            isFirstSuccess = false;
        }

        const now = Date.now();
        if (results.multiHandLandmarks) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                let label = results.multiHandedness && results.multiHandedness[i] ? results.multiHandedness[i].label : 'Right';
                if (handInstances.has(label)) handInstances.get(label).update(results.multiHandLandmarks[i], now);
            }
        }
        
        // UI æ›´æ–°
        let anyPinch = false, anyTurbo = false, anyPalm = false;
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen < 200) {
                if (hand.gesture.isPinching) anyPinch = true;
                if (hand.gesture.isTurbo) anyTurbo = true;
                if (hand.gesture.isPalmOpen) anyPalm = true;
            }
        }

        if (anyPalm && (now - globalGestureState.lastColorChangeTime > 1200)) {
            globalGestureState.lastColorChangeTime = now;
            currentColorIdx = (currentColorIdx + 1) % colors.length;
            const flash = document.createElement('div');
            flash.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;background:hsl(${colors[currentColorIdx].hue},50%,50%);opacity:0.2;pointer-events:none;z-index:999;transition:0.3s`;
            document.body.appendChild(flash);
            setTimeout(() => { flash.style.opacity = 0; setTimeout(()=>flash.remove(),300); }, 50);
        }

        badges.pinch.className = 'badge ' + (anyPinch ? 'active' : '');
        badges.peace.className = 'badge ' + (anyTurbo ? 'active' : '');
        badges.palm.className = 'badge ' + (anyPalm ? 'active' : '');
    }

    // 6. æ¸²æŸ“å¾ªç¯
    function loop() {
        requestAnimationFrame(loop);
        bgCtx.fillStyle = 'rgba(5, 5, 8, 0.25)';
        bgCtx.fillRect(0, 0, width, height);
        fgCtx.clearRect(0, 0, width, height);

        // èƒŒæ™¯ç²’å­
        for (let i = bgParticles.length - 1; i >= 0; i--) {
            let p = bgParticles[i]; p.update(); p.draw(bgCtx);
            if (p.life <= 0) bgParticles.splice(i, 1);
        }

        const now = Date.now();
        // æ‰‹éƒ¨ç»˜åˆ¶
        for (let hand of handInstances.values()) {
            if (now - hand.lastSeen > 200) continue;
            
            // ç»˜åˆ¶ä»™å¥³æ£’
            fgCtx.save();
            fgCtx.translate(hand.pos.x, hand.pos.y);
            fgCtx.rotate(hand.stickAngle * Math.PI / 180);
            fgCtx.strokeStyle = "#e0e0e0"; fgCtx.lineCap = "round"; fgCtx.lineWidth = 12; 
            fgCtx.beginPath(); fgCtx.moveTo(0, 0); fgCtx.lineTo(0, 180); fgCtx.stroke();
            fgCtx.strokeStyle = "#a0a0a0"; fgCtx.lineWidth = 4;
            fgCtx.beginPath(); fgCtx.moveTo(0, 20); fgCtx.lineTo(0, 170); fgCtx.stroke();
            fgCtx.fillStyle = "#ffd700"; fgCtx.fillRect(-7, 50, 14, 4); fgCtx.fillRect(-7, 80, 14, 4);
            const shouldEmit = hand.gesture.isPinching || hand.gesture.isTurbo;
            fgCtx.fillStyle = shouldEmit ? "#fff" : "#666";
            fgCtx.fillRect(-8, -15, 16, 45); 
            if (shouldEmit) {
                fgCtx.shadowBlur = hand.gesture.isTurbo ? 60 : 35; fgCtx.shadowColor = "#ffeb3b";
                fgCtx.fillStyle = "#fff"; fgCtx.beginPath(); fgCtx.arc(0, 0, hand.gesture.isTurbo ? 16 : 10, 0, Math.PI*2); fgCtx.fill();
            }
            fgCtx.restore();

            // å‘å°„ç²’å­
            if (shouldEmit) {
                let count = hand.gesture.isTurbo ? 10 : 5;
                for(let i=0; i<count; i++) {
                    fgParticles.push(new Particle(hand.pos.x, hand.pos.y, 'fg', hand.velocity, hand.gesture.isTurbo));
                }
            }
        }

        // å‰æ™¯ç²’å­
        for (let i = fgParticles.length - 1; i >= 0; i--) {
            let p = fgParticles[i]; p.update(); p.draw(fgCtx);
            if (p.life <= 0) fgParticles.splice(i, 1);
        }
    }
    
    // UI æ§åˆ¶å‡½æ•°
    function toggleSettings() {
        const p = document.getElementById('settings-panel');
        p.style.display = p.style.display === 'flex' ? 'none' : 'flex';
    }
    function updateSettings() {
        appSettings.dualMode = document.getElementById('dual-mode-toggle').checked;
        appSettings.bgStyle = document.getElementById('bg-style-select').value;
        if(hands) hands.setOptions({ maxNumHands: appSettings.dualMode ? 2 : 1 });
        resetBgGenerator();
    }
    function exitToRPG() {
        if(videoElement.srcObject) videoElement.srcObject.getTracks().forEach(t=>t.stop());
        window.parent.postMessage("CLOSE_AR_WINDOW", "*");
    }

    // å¯åŠ¨æ¸²æŸ“å¾ªç¯
    loop();

</script>
</body>
</html>